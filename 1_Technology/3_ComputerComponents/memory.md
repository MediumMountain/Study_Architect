# memory

## VRAM(GPUメモリ)
- グラフィックボードに搭載されていてグラフィックの処理にのみ特化したメモリ

- GPUメモリが多いことによる恩恵
    - 高解像度でゲームができる
    - 高いテクスチャ環境でゲームができる
    - アンチエイリアス処理をしていても快適なプレイができる
    - 高解像度の3Dグラフィックスの処理が効率的に行える

- GPUメモリの役割
    - テクスチャの読み込み
    - フレーム・バッファーの保持
    - Zバッファーの保持

```
処理性能とメモリ容量は別問題
```


## 命令
- 命令コード
- 命令キャッシュ
    - 一度アクセスした命令コードはサイドアクセスされる可能性が高い。
    - そこで、主記憶から読みだした命令コードを命令キャッシュに保存しておくと、再度アクセスする際に高速な命令キャッシュ参照が可能になる。
    - それによって全体のアクセス時間を短縮できる。
    


## 平均アクセス時間
- ヒット率
    - 読み込みたい命令コードが命令キャッシュに存在する確率
- ミスヒット率
    - 存在しない確率

- 平均アクセス時間は、命令キャッシュ及び主記憶のアクセス時間をヒット率とミスヒット率で加重平均したもの

```
(平均アクセス時間)=(命令キャッシュのアクセス時間)*(ヒット率) + (主記憶のアクセス時間)*(ミスヒット率)
```

- 命令キャッシュ及び主記憶の容量は平均アクセス時間に影響しない。


## 大容量化

## 高速化
## 高信頼化
## キャッシュメモリ
- 主記憶上の格納位置とキャッシュメモリ上の格納位置とをどのように対応させるかを決める方式として、ダイレクトマップ、フルアソシエイティブ、セットアソシエイティブがあります。
1. ダイレクトマップ
    - ハッシュ演算などにより、主記憶のブロック番号からキャッシュメモリのブロック番号が一意に定まる方式。
    - 主記憶のブロックとキャッシュメモリのブロックが1対1で対応する
1. フルアソシエイティブ
    - 主記憶のブロックをキャッシュメモリ上のどのブロックにも格納することができる方式
    - 任意のキャッシュメモリのブロックを主記憶のどの部分にも割り当てられる。
1. セットアソシエイティブ
    - キャッシュメモリのブロックを連続した一定数ごとにまとめた"セット"を用意し、主記憶のブロック番号から対応する"セット"が一意に定まり、そのセット内のブロックならどこでも格納できる方式。
    - ダイレクトマップとフルアソシエイティブの中間的な存在で、現在ほぼすべてのCPUアーキテクチャで採用されている



ライトバック(write back)
CPUから書込み命令が出たときにキャッシュメモリだけに書き込み、主記憶への書き込みはキャッシュメモリからデータが追い出されるときに行う方式。高速に書き込みできるがデータの整合性を保つための制御が余分に必要になる。
ライトスルー(write through)
CPUから書き込む命令が出たときにキャッシュメモリと同時に主記憶にも書き込む方式。データの整合性は得られるが処理速度は遅い。



ウェアレベリング(Wear Leveling)は、電子記憶媒体において、全体的にどのブロックも均等に使うように物理的な書込み位置を制御することです。フラッシュメモリのように書換え可能回数に制限がある記憶媒体では、同じブロックへの書込みと消去が集中するとそのブロックが先に不良となってしまいます。記憶媒体の寿命を延ばすために、このような制御が行われています。
各ブロックの書込み回数がなるべく均等になるように，物理的な書込み位置を選択する。
正しい。ウェアレベリングの説明です。
記憶するセルの電子の量に応じて，複数のビット情報を記録する。
マルチレベルセル(Multi Level Cell)の説明です。これとは対照的に、1つのセルに1つのビットしか記録しない方式をシングルレベルセル(Single Level Cell)と言います。
不良のブロックを検出し，交換領域にある正常な別のブロックで置き換える。
不良ブロック管理におけるリアロケーションの説明です。
ブロック単位でデータを消去し，新しいデータを書き込む。
ブロックアクセス方式の説明です。




## メモリの4領域
メモリは下記の4領域に分けられる。

### テキスト領域(Program/Code)
機械語に翻訳されたプログラムが格納される。CPUの命令コードが格納されている領域。
この機械語の命令が 1 行づつ実行されることでプログラムが動く。
テキスト領域は読み出し専用なので、プログラム上でテキスト領域に書き込もうとすると割り込みが発生する。
ROM/RAM上であり、コンパイラがはきだす！変更しない領域が入る時はROM上で行われる。

### 静的領域(Static/Data)
プログラムの中で初期値をもつような変数に割り当てられる領域。
グローバル変数や静的変数(static 変数)が割り当てられる。
ROM/RAM上であり、コンパイラがはきだす！変更しない領域が入る時はROM上で行われる。

### ヒープ領域
動的にメモリ領域の確保や解放を行うのがヒープ領域。Swiftの場合、classが割り当てられるのがヒープ領域。
動的にサイズが確保されるため、実行中にヒープ領域のサイズが変化する。
ヒープ領域のアドレスは先に確保したものから小さい順に割り当てられる。
RAM上であり、ランタイムで確保する！

### スタック領域
関数内にあるローカル変数や、関数への引数、戻り値などに割り当てられるのがスタック領域。Swiftの場合、structが割り当てられるのがスタック領域で、ポインタで管理されている！メモリの示す先を必要なバイト数ずらしている。
スタック領域のアドレスは、先に確保したものから大きい順に割り当てられる。
RAM上であり、ランタイムで確保する！
スタック領域はコンパイラが最大何バイトか決めており、その領域をオーバーすると、スタック・オーバーフローが起こる！