# マルチプロセス(マルチタスク)とマルチスレッドの違い
- １つのPCで複数のプロセスを並行して処理を行うことをマルチプロセスと言う。また、１つのプロセスに複数のスレッドが存在し並行して処理を行うことをマルチスレッドと言う。 


### プロセスとは
- OSによって与えられたプログラムの実行単位である。
- プログラムコードに記された命令を実行して情報処理すること

## OSのメモリ管理のしくみ
- OSによって提供された個別のプロセス用のメモリ空間の事をプロセスインスタンスと呼ぶ。
- OSは仮想アドレス番号を物理メモリに与えてプロセスに提供する。
    - プロセスは処理を実行するときに仮想アドレスでメモリにアクセスする。
    - OSは都度、仮想アドレスを物理アドレスに変換してメモリにアクセスする。
    - プロセスは物理アドレスの状態を意識する必要はない。

- プロセスは提供された仮想アドレスの範囲内のメモリ空間にしかアクセスできない。
- OSは他のプロセスの使用するメモリ領域はアクセスできない。

### プロセス・インスタンス (Process Instance)
- 現実のイベントに応じ、特定のプロセスで実行される一組のアクティビティと作業アイテムのこと。
- プロセス実行エンジンでは、通常、複数のプロセス・インスタンスが並行的に実行される。


## マルチプロセス
- メモリ空間はプロセスインスタンスで各プロセスごとに分割できるが、CPUは一つしか無い。
    - そのため、時間で分割する。

- ハードウェアのタイマーでCPUに一定時間ごとに割り込みを入れ、CPUに割り当てるプロセスを切り替える。
- CPUを複数のプロセスで時分割で共有することをタイムスライスと呼ぶ。


## マルチスレッド
- マルチスレッドは一つのプロセスインスタンスの中でファイルIOやキーボードの入力待ちなどが発生したときでも、CPUを待たせずに効率良くCPUを使用する為に、一つのプロセスインスタンスの中で、タイムスライスを使用して複数の処理を並列実行する仕組みである。

    一つのプロセスが内部に複数のスレッドを持ち、CPUをタイムスライスで共有して並列実行する。  
    マルチプロセスと違い、プロセスの中のスレッドはスレッド専用のインスタンスを持たない。  
    スレッドは直接プロセスインスタンスにアクセスする。


- プロセスがアクセスするのはOSによって提供される仮想アドレスだが、スレッドにはそのようなメモリ保護の仕組みが無く、仮想仮想アドレスのようなものはない。
- よってスレッドは直接プロセスインスタンスの仮想アドレスにアクセスする。

    スレッドが複数あると、互いにメモリの同じ場所にアクセスしてしまうことで、メモリデータの不整合が生じたり、互いに更新待ち(デッドロック)になる場合がある。  
    そのため、マルチスレッドでプログラムを作成するときプログラマーはスレッドのメモリ管理に注意して作らなければならない。  

    スレッドとスレッドの使用しているメモリ領域が重ならないように人間が管理しなければならない。  
    (あくまで原則としてだがクラスライブラリなどでこの管理を代行してくれる物もある)

    プロセスのメモリ管理はOSが自動で行ってくれるが、スレッドのプロセス内のメモリ管理はプログラマーが手作業で管理するコード(プログラム)を書く。  

    メモリ管理を失敗すると非常に分かりにくいバグが生じる。発見するのは容易ではない。
    またスレッドがプロセスのメモリを干渉するので、スレッドがダウンするとプロセスごとダウンしてしまう。  

- マルチスレッドがよく使われるのは、処理中に待機時間が生じる処理である。


## メモリモデル
- プロセスインスタンスの中のメモリ空間は単純化すると次の4つに分かれる。
1. 共有領域
    - 主にグローバル変数の配置場所となる。
    - プログラムの全ての関数からアクセス可能な領域である。
    - 領域の範囲やサイズを実行中に変更することができない。

1. ヒープ領域
    - プログラム実行中に必要なサイズの連続したメモリ領域を確保する為の場所である。
    - C言語では malloc() という関数によって確保する。
    - 使い終われば実行中に解放する。
    - 大きなメモリ領域を確保するのに向いている。
    - メモリ管理はプログラマーが手作業でコードに書く。
    - この領域に確保したメモリ領域を開放しなければ、メモリーリークというメモリ不足状態になる。
    - メモリーリークは非常に発見しにくいバグである。

1. スタック領域
    - 主な変数や配列などの領域確保に使用する。
    - メモリ管理が簡素な仕組みで自動化されており、メモリ管理がやりやすい。
    - 現代のプログラミング言語はほとんどこのスタック領域を使用するように設計されている。
    - スレッドの場合プロセスが新規スレッドを作成するとき、そのスレッドが使用できるプロセスインスタンスの一部を開始アドレスとサイズを指定して貸し与える。
    - 貸し与える領域は「プロセスインスタンスのヒープ領域」を貸し与えることも可能だし、「プロセスインスタンスのスタック領域」を貸し与えることもできる。
    - スレッドは全て専用のスタック領域を有することになる。
    - ただし他のメモリ領域にアクセスすることは可能になっている。
    - メモリ保護は行われない。

    - スタック（LIFO)という概念
        https://www.wake-mob.jp/2019/05/lifo.html

1. コード領域
    - プログラムの命令部分が格納される領域である。
    - 定数などもこの領域に存在する。
    - 書き換え不可能で、そのサイズも変更されることはない。
    - 命令を保存しているだけなのでその必要が無い。



## スレッドセーフ

- マルチスレッドのプログラミングではスレッドのメモリ管理をやりやすいようにスレッドセーフという制約を作ることで、各スレッドのメモリ領域を分割して互いに干渉しないようにする。  
これはプログラマーが意識的にプログラミングする時に行う。  
当然、スレッドセーフを間違えて実装するとスレッド間のメモリ干渉が起きる。

    スレッドセーフは、スレッドが使用するメモリ領域の大半をスレッドに割り当てられたスタック領域内に確保する。  
    ヒープや共有領域も少しは使用するが、これらを使用する時は排他制御の処理が組み込まれる。  
    通常はあるスレッドが使用している場合は、他のスレッドが使用できない。  
    ここを多用するとマルチスレッドを使用する意味が無い。  
    だから使用するメモリ領域の大半にスタック領域を使用する。  


    各スレッドは作成時に専用のスレッド領域を有するので、スタックを使用している限り、互いのメモリ領域を干渉することはない。  

    他のスレッドと情報交換する時や、実行状態を記録する場合は、排他制御してヒープや共有領域を使用する。  

    この制約を守り、作成されたプログラムのソースコードをスレッドセーフ(Thread-safe)と呼ぶ。  

    ちなみにこの制約を守っていないコードをノンスレッドセーフ(Non Thread-safe)と呼ぶ。  
    主にシングルスレッド用のコードである。  

    マルチプロセスのシングルスレッド処理を行うときに使用する。  
    制約がない方が自由なコードが書けるので必要が無ければスレッドセーフは使用されない。  


# 並列処理



# 並行処理