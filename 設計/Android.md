# Android


# 構成
- Androidは5つのスタックで構成される。
    1. Linuxカーネル
    1. 標準的なライブラリ
    1. AndroidRuntime（アプリケーションを実行するための実行環境）
    1. アプリケーション・フレームワーク
    1. アプリケーション

[](../PIC/fig2.jpg)


## Linuxカーネル
- AndroidはOSとしてLinuxカーネルを採用している。
- Linuxカーネルは，メモリーやプロセスの管理，ファイル・システム，セキュリティといった基本機能に加え，各種ドライバを提供する。
- いずれも通常のLinuxディストリビューションと同様，不可欠な機能である。

- Androidのアプリケーションは必ず，AndroidRuntimeやフレームワーク層を介して動作する。
- そのため，アプリケーションの開発時にカーネルを意識することはない。

- OHAは，Androidの開発に当たってカーネルに独自ドライバを数種追加している。
- それらの中でAndroidの特徴を表すドライバには次のようなものがある。

    - LowMemoryKiller
        - このドライバは，メモリーが不足した時に，不要なプロセスを自動的に停止する。
        - LowMemoryKillerを加えたのは，次のような事情がある。  
            Androidの各アプリケーションは，システム上の1プロセスとして起動される。  
            通常のLinuxディストリビューションであれば，ソフトウエアの終了はプロセスの停止を意味する。  
            しかし，Androidの場合はユーザーがアプリケーションを終了しても，プロセス自体はすぐには停止しない。  
            その理由は，一般的なPCとは違い，携帯端末では消費電力が問題になるからである。  
            プロセスの生成は一般的な処理に比べて，CPUをはじめとするコンピュータ・リソースの消費量が非常に大きい。  
            ユーザーがアプリケーションを切り替えるたびに，プロセスの終了と生成を繰り返していては，バッテリの持続時間が短くなってしまう。  
            そのため，使われなくなったアプリケーションのプロセスも，すぐに終了せず，待機状態にしておく。  
            もし，待機しているアプリケーションの起動が要求されたら，待機中のプロセスを利用し，プロセス生成のコストを低減するのである。  
            この際，単に多くのプロセスを起動させていては，メモリーそのものが不足する問題が発生する。  
            そこで，メモリーの不足したタイミングで，使われなくなったアプリケーションのプロセスをLowMemoryKillerが終了させる。  
            これにより，メモリーを解放してシステム全体の負荷バランスを保っている。

    - KernelDebugger
        - このドライバは，デバッガを使ったデバッグ環境をアプリケーション開発者に提供する。

        - 携帯端末で動作するAndroidでは通常，開発環境と実行環境が異なる。  
        PCでアプリケーションを開発し，最終的には携帯端末の実機上でテストする。  
        その際，何らかの不具合が発生した場合，発生した時点の携帯端末内部の状態を調べる必要がある。  
        そのための手段がなければ，プログラムを探るしか方法が無く，開発者は非常に不便を強いられる。

        - KernelDebuggerは，“リモート・デバッグ”に似た仕組みを開発者に提供する。  
        つまり，テストの対象となる携帯端末内部の状態を，携帯端末に接続した外部（リモート）の端末から調べることができる。

        - 例えば，開発者は，携帯端末上でアプリケーションをテストする際に，開発環境上で設定したブレークポイント（プログラムを停止するポイント）で，端末上のアプリケーションを中断し，中断した時点での各変数の値を参照できる。  
        高価なハードウエアを必要としないデバッグ手段は，開発者にとっては大きなメリットになる。

●Binder
- プロセス間で通信する機能を提供するドライバ。

- Binderの役割を理解するために，まずAndroidアプリケーションの構造を説明しよう。  
Androidのアプリケーションは大きく分ければ，「アクティビティ」と「サービス」という2つの要素で構成されている。  
通常，一つのアプリケーションには，アクティビティとサービスの両方，あるいは一方だけが含まれている。  
アクティビティは，一つの画面を持つプログラムだ。  
画面が表示されている間は実行中となるが，ユーザーが終了したり，電話の着信などの割り込みが発生して画面が消えたりすると，待機状態になる（詳しくは後述）。  
一方，サービスは，画面を持たず常にバックグラウンド・プロセスとして動作するプログラムだ。システムに常駐し，他のアプリケーションからの要求に応じて処理を実行する“デーモン”プログラムに近い。  
サービスはそれ自身が画面を持たないため，ユーザーがパラメータを設定する際は，画面を持つアクティビティを介す。  
しかし，サービスとアクティビティは，それぞれ動作するプロセスが異なる場合もあるので，プロセス間通信の仕組みが必要となる。  
例えば，電波状態を表示するアプリケーションの設定画面（アクティビティ）と実行処理のプログラム（サービス）とでプロセス間通信を利用している（詳しくは後述）。    
そのプロセス間通信を実現するのが，このBinderドライバである。  
実際の通信は，カーネルより上のフレームワーク層が制御する。  
アプリケーション開発者は，AIDL（AndroidInterfaceDefinitionLanguage）と呼ぶ記述言語で入出力のインタフェースを定義するだけでよく，ドライバを直接意識しないで済む。


## ライブラリ(カーネル層の上に位置するライブラリ群)

　Androidは，CまたはC++で開発されたライブラリを標準で含んでいる。これらのライブラリの機能は，アプリケーションの開発過程で使うが，直接操作することはなく，一般的には後述する各アプリケーションのフレームワークを経由して利用する。

　以下に，代表的なライブラリについて示す。

●SurfaceManager

　「SurfaceManager」は，グラフィックス・レイヤを合成して一つの画面に表示する仕組みをアプリケーションに提供する描画ライブラリだ。グラフィック・レイヤを使うと，アプリケーションを経由しないで画面表示が可能なため，高速に描画できる。アプリケーションからは主に，カメラやGPU（GraphicsProcessingUnit）といったハードウエアからのデータを，高速に描画するために利用する。

●MediaFramework

　画像の表示や音声・動画のエンコードとデコードの処理を実行するライブラリ。米PacketVideo社のメディア再生用ライブラリ「OpenCORE」をベースに開発されている。対応するフォーマットには，音声では「mp3」や「aac」など，動画では「h.263」や「h.264」などがある。

●SQLite

　高速なリレーショナル・データベース・エンジン。データ管理の機能を提供する。格納する電話番号を比較するなど，Android用に文字列を処理する機能が追加されている。

　アプリケーションからは，フレームワークを介してリレーショナル・データベースとして利用する。フレームワークにある「ContentProvider」（次回以降で解説）のような，アプリケーション間のデータ共有の仕組みの中でも利用されている。

●OpenGLES

　ハードウエア・アクセラレータを使った高速な3D描画を実現する3Dグラフィックス・ライブラリ。OpenGLES1.0*に準拠している。

＊ 【OpenGLES】組み込み機器向けのグラフィックAPIを策定する業界団体「KhronosGroup」が公開している仕様。
●WebKit

　HTMLまたはXHTMLの描画を担当するライブラリ。内部に，高速なJavaScriptエンジンである「SquirrelFish」が搭載されている。開発者がアプリケーションの画面にWebページを表示する場合に利用する画面部品（ウィジェット）である「WebView」にも機能を提供している。

●libc（bionic）

　Android用のCライブラリ。BSDのCライブラリを基に開発されており，x86とARMに対応している。標準規格に沿ったlibcと比べ，ロケール（各国語対応）やマルチバイト文字に対応していない，C++の例外に対応していないなど，最低限の実装のみサポートしている。携帯端末上での動作を最適化するために，「機能を限定してライブラリが肥大化してしまうことを防止する」という方針で開発されている。





# REFERENCE
【Android】分かった気になれる！アーキテクチャ・MVVM概説
https://qiita.com/iTakahiro/items/6b1b22efa69e55cea3fa